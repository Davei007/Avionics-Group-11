//The SDA AND SCL are on port 8&9 and there are used by both modules

#include <Wire.h>
#include <Adafruit_GFX.h>
#include <Adafruit_SSD1306.h>
#include <math.h>

#define SCREEN_WIDTH 128 // OLED display width, in pixels
#define SCREEN_HEIGHT 64 // OLED display height, in pixels
#define BMI160_ADDR 0x68
#define OLED_ADDR 0x3C

// Registers
#define BMI160_CHIP_ID     0x00
#define BMI160_CMD         0x7E
#define BMI160_ACC_DATA    0x12
#define BMI160_GYR_DATA    0x0C
#define BMI160_ACC_RANGE   0x41
#define BMI160_GYR_RANGE   0x42

// Complementary filter coefficient (0-1)
#define alpha 0.98

// Declaration for an SSD1306 display connected to I2C (SDA, SCL pins)
Adafruit_SSD1306 display(SCREEN_WIDTH, SCREEN_HEIGHT, &Wire, -1);

// Timing
unsigned long prevTime = 0;

// Filtered angles
float pitch = 0.0;
float roll = 0.0;

// I2C helper functions
void writeRegister(uint8_t reg, uint8_t value) {
  Wire.beginTransmission(BMI160_ADDR);
  Wire.write(reg);
  Wire.write(value);
  Wire.endTransmission();
}

void readRegisters(uint8_t reg, uint8_t *buffer, uint8_t len) {
  Wire.beginTransmission(BMI160_ADDR);
  Wire.write(reg);
  Wire.endTransmission(false);
  Wire.requestFrom(BMI160_ADDR, len);
  for (uint8_t i = 0; i < len; i++)
    buffer[i] = Wire.read();
}

void setup() {
  Serial.begin(115200);   

  Wire.setSDA(8);
  Wire.setSCL(9);
  Wire.begin();
  delay(100);

   // Initialize OLED
  if (!display.begin(SSD1306_SWITCHCAPVCC, OLED_ADDR)) {
    Serial.println("OLED failed");
    while (1);
  }

  display.clearDisplay();
  display.display();

  // Check chip ID
  uint8_t chipID;
  readRegisters(BMI160_CHIP_ID, &chipID, 1);
  if (chipID != 0xD1) {
    Serial.println("BMI160 not detected!");
    while (1);
  }
  Serial.println("BMI160 detected!");

  // Enable accelerometer & gyroscope (normal mode)
  writeRegister(BMI160_CMD, 0x11); // accel normal
  delay(50);
  writeRegister(BMI160_CMD, 0x15); // gyro normal
  delay(50);

  // Set ranges
  writeRegister(BMI160_ACC_RANGE, 0x03); // ±2g
  writeRegister(BMI160_GYR_RANGE, 0x00); // ±2000°/s

  prevTime = millis();
}

void loop() {
  unsigned long currentTime = millis();
  float dt = (currentTime - prevTime) / 1000.0;
  prevTime = currentTime;

  // Read accelerometer
  uint8_t accBuf[6];
  readRegisters(BMI160_ACC_DATA, accBuf, 6);
  int16_t ax = (int16_t)((accBuf[1] << 8) | accBuf[0]);
  int16_t ay = (int16_t)((accBuf[3] << 8) | accBuf[2]);
  int16_t az = (int16_t)((accBuf[5] << 8) | accBuf[4]);

  float accelX = ax / 16384.0;
  float accelY = ay / 16384.0;
  float accelZ = az / 16384.0;

  // Calculate accelerometer angles
  float pitchAcc = atan2(-accelX, sqrt(accelY*accelY + accelZ*accelZ)) * 180.0 / PI;
  float rollAcc  = atan2(accelY, accelZ) * 180.0 / PI;

  // Read gyroscope
  uint8_t gyrBuf[6];
  readRegisters(BMI160_GYR_DATA, gyrBuf, 6);
  int16_t gx = (int16_t)((gyrBuf[1] << 8) | gyrBuf[0]);
  int16_t gy = (int16_t)((gyrBuf[3] << 8) | gyrBuf[2]);
  // int16_t gz = (int16_t)((gyrBuf[5] << 8) | gyrBuf[4]); // unused for now

  float gyroX = gx / 16.4; // 2000°/s range → 16.4 LSB/°/s
  float gyroY = gy / 16.4;

  // Complementary filter
  pitch = alpha * (pitch + gyroX * dt) + (1 - alpha) * pitchAcc;
  roll  = alpha * (roll  + gyroY * dt) + (1 - alpha) * rollAcc;

  // Print results
  Serial.print("Pitch: ");
  Serial.print(pitch, 2);
  Serial.print("°  Roll: ");
  Serial.print(roll, 2);
  Serial.println("°");

  /// ____OLED Display _____
  
  display.clearDisplay();
  display.setTextSize(0.5);
  display.setTextColor(WHITE);

  display.setCursor(0, 0);
  display.println("Pitch: ");
  display.setCursor(0, 20);
  display.println(pitch, 2);
  display.print(" deg");
  display.display();

  display.setCursor(0, 40);
  display.println("Roll: ");
  display.setCursor(0, 55);
  display.println(roll, 2);
  display.print(" deg");

  display.display();

  delay(50);
}
